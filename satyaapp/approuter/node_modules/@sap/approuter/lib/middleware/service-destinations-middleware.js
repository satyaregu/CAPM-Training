'use strict';

const bsUtils = require('../utils/business-service-utils');
const logRequestInfo = require('../utils/application-logs-utils').logRequestInfo;
const urlUtils = require('../utils/url-utils');
const urijs = require('urijs');
const svc2Approuter = require('./service-to-approuter-middleware');
let svc2ApprouterProm = (req, res) => {
  return new Promise((resolve, reject) => {
    svc2Approuter(req, res, (err) => err ? reject(err) : resolve()).catch(reject);
  });
};
const jwtDecode = require('jwt-decode');
const applicationLogUtils = require('../utils/application-logs-utils');
const passportUtils = require('../passport/utils');
const html5RepoUtils = require('../utils/html5-repo-utils');
let getHTML5Applications = html5RepoUtils.getHTML5Applications; // let for testing
const drUtils = require('../utils/dynamic-routing-utils');
const { promisify } = require('util');
const appCacheUtils = require('../utils/app-cache-utils');
let getDestHTML5Applications = promisify(bsUtils.getHTML5Applications); // let for testing
const cacheBSDestinationsProm = promisify(bsUtils.cacheBSDestinations);
const GET_APPLICATIONS_API = '/applications';
const DOWNLOAD_APPLICATIONS_API = '/applications/content';
const GET_APPLICATION_LOGS_API = '/applicationLogs';
const DYNAMIC_LOG_LEVEL = '/dynamicLogLevel';

module.exports = async function cacheServiceDestination(req, res, next) {
  if (!process.env.SAAS_APPROUTER || isExcluded(req)) {
    return next();
  }

  try {
    getTenant(req);
    getDisableDestCredentialsAccess(req);
    const apiName = await getApiName(req, res);
    await cacheAndGetCredentials(req);
    apiName === GET_APPLICATIONS_API && await getApplications(req, res);
    apiName === DOWNLOAD_APPLICATIONS_API && await downloadApplication(req, res);
    apiName === GET_APPLICATION_LOGS_API && await applicationLogUtils.getApplicationLogs(req, res);
    apiName === DYNAMIC_LOG_LEVEL && await dynamicLogLevel(req, res);
    !apiName && next();
  } catch (err) {
    next(err);
  }
};

async function downloadApplication(req, res) {
  if (req.disabledDestCred) {
    return await html5RepoUtils.downloadHTML5Application(req, res);
  }
  try {
    await bsUtils.downloadHTML5Application(req, res);
  } catch (err) {
    if (err.statusCode !== 404) {
      throw (err);
    }
    !isHTML5RepoCredsExcluded(req) && await html5RepoUtils.downloadHTML5Application(req, res);
  }
}

async function getApplications(req, res) {
  const skipExternalCache = req.headers['x-approuter-authorization'] && req.headers['x-skip-external-cache'];
  const excludeHTML5RepoCreds = isHTML5RepoCredsExcluded(req);
  const compactResponse = req.headers['x-compact-response'] === 'true';
  const queryParams = req.url.split('?')[1];
  let cacheKey = queryParams ? `${req.tenant}_${queryParams}` : `${req.tenant}`;
  if (excludeHTML5RepoCreds) {
    cacheKey = cacheKey + '_excludeHTML5RepoCreds';
  } else if (req.disabledDestCred) {
    cacheKey = cacheKey + '_excludeDestCreds';
  }

  // If skipExternalCache is true, bypass the cache reading and lock mechanism
  // Directly fetch fresh data, but still write to cache after fetching data
  if (skipExternalCache) {
    const apps = await fetchApplicationsList(req, excludeHTML5RepoCreds);
    const compactApps = buildCompactApps(apps.applications);
    const cacheValue = {apps: compactApps,errors: apps.errors};
    await appCacheUtils.setAppsCache(cacheKey, cacheValue, req);

    return await sendApplicationsResponse(req, res, {
      data: compactResponse ? cacheValue : apps,
      cacheStatus: 'miss',
      compactResponse,
      enrich: false,
      queryParams
    });
  }

  // For skipExternalCache = false, use winner/waiter loop
  const lockKey = req.tenant; // Tenant-specific lock key
  const routerConfig = req.app.get('mainRouterConfig');
  const maxWaitTime = routerConfig.maxWaitTime;
  const lockTTL = routerConfig.lockTTL;
  const pollingInterval = routerConfig.pollingInterval;

  const startTime = Date.now();
  while (Date.now() - startTime < maxWaitTime) {
    // 1. Check cache before trying to acquire lock
    const cachedApps = await appCacheUtils.getAppsCache(cacheKey, req);
    if (cachedApps) {
      return await sendApplicationsResponse(req, res, {
        data: cachedApps,
        cacheStatus: 'hit',
        compactResponse,
        enrich: true,
        queryParams
      });
    }

    // 2. Try to acquire lock
    const { acquired, token } = await appCacheUtils.acquireLock(lockKey, lockTTL, req);
    if (acquired) {
      // Double-check cache after acquiring lock
      const cachedAppsAfterLock = await appCacheUtils.getAppsCache(cacheKey, req);
      if (cachedAppsAfterLock) {
        await appCacheUtils.releaseLock(lockKey, token, req);
        return await sendApplicationsResponse(req, res, {
          data: cachedAppsAfterLock.apps,
          cacheStatus: 'hit',
          compactResponse,
          enrich: true,
          queryParams
        });
      }

      let renewInterval = null;
      try {
        // Lease renewal: renew every lockTTL/3 ms
        renewInterval = setInterval(() => {
          appCacheUtils.renewLock(lockKey, token, lockTTL, req);
        }, Math.floor(lockTTL / 3));

        const apps = await fetchApplicationsList(req, excludeHTML5RepoCreds);
        const compactApps = buildCompactApps(apps.applications);
        const cacheValue = {apps: compactApps,errors: apps.errors};
        await appCacheUtils.setAppsCache(cacheKey, cacheValue, req);
        return await sendApplicationsResponse(req, res, {
          data: compactResponse ? cacheValue : apps,
          cacheStatus: 'miss',
          compactResponse,
          enrich: false,
          queryParams
        });
      } finally {
        clearInterval(renewInterval);
        await appCacheUtils.releaseLock(lockKey, token, req);
      }
    }

    // 3. Wait before next attempt
    await new Promise(resolve => setTimeout(resolve, pollingInterval));
  }

  // If we get here, maxWaitTime expired
  logRequestInfo(req, `Timeout waiting for cache or lock for key: ${cacheKey}`);
  res.statusCode = 504;
  res.end(JSON.stringify({ error: 'Timeout waiting for cache or lock' }));
}

async function fetchApplicationsList(req, excludeHTML5RepoCreds) {
  const html5Applications = !req.disabledDestCred && await getDestHTML5Applications(req);
  let html5ApplicationsRepo = { applications: [] };
  if (!excludeHTML5RepoCreds) {
    html5ApplicationsRepo = await getHTML5Applications(req);
  }
  if (html5ApplicationsRepo.applications.length > 0 && html5Applications) {
    html5Applications.applications = html5Applications.applications.concat(html5ApplicationsRepo.applications);
  }
  const apps = html5Applications || html5ApplicationsRepo;
  if (apps && apps.applications) {
    apps.applications = apps.applications.filter(app => (app.applicationType !== html5RepoUtils.technicalCacheBusterApplication));
    if (excludeHTML5RepoCreds) {
      apps.applications = apps.applications.filter(app => (app.destinationId || app.destinationName));
    }
  }
  return apps;
}

function buildCompactApps(appsList) {
  const compactApps = {};
  appsList.forEach(app => {
    const appHostId = app.appHostId || app['app-host-id'];
    const sapCloudService = app.sapCloudService || app['sap.cloud.service'];
    if (!compactApps[appHostId]) {
      compactApps[appHostId] = {
        urls: [],
        destIds: [], // just for semantic service
        appIds: [], // just for semantic service
        destinationName: app.destinationName,
        xsappname: app.xsappname,
        sapCloudService: sapCloudService,
      };
      app.subscribedAppName && (compactApps[appHostId].subscribedAppName = app.subscribedAppName);
      app.subscribedCommercialAppName && (compactApps[appHostId].subscribedCommercialAppName = app.subscribedCommercialAppName);
    }
    const pathName = new URL(app.url).pathname;
    compactApps[appHostId].urls.includes(pathName) || compactApps[appHostId].urls.push(pathName);
    // just for semantic service
    app.destinationId && !compactApps[appHostId].destIds.includes(app.destinationId) && compactApps[appHostId].destIds.push(app.destinationId);
    compactApps[appHostId].appIds.includes(app.applicationId) || compactApps[appHostId].appIds.push(app.applicationId);
  });
  return compactApps;
}

async function sendApplicationsResponse(req, res, {
  data,
  cacheStatus,
  compactResponse,
  enrich = false,
  queryParams
}) {
  res && res.setHeader('Content-Type', 'application/json; charset=utf-8');
  res && res.setHeader('x-app-cache', cacheStatus);

  let responseData = compactResponse ? data.apps : data;
  if (enrich && !compactResponse) {
    const enriched = await html5RepoUtils.enrichWithHTML5RepoData(data, queryParams, req);
    responseData = enriched || data;
  }
  res && res.end(JSON.stringify(responseData, null, 4));
}

async function cacheAndGetCredentials(req) {
  if (req.headers['x-approuter-authorization'] && !req.headers['x-destination-cache']
    && !process.env.SAAS_APPROUTER_CACHE_DESTINATIONS) {
    req.skipCachedApps = true;
    return;
  }
  const appKey = drUtils.getApplicationKey(urlUtils.getFirstUrlSegment(req,true));
  const serviceName = appKey && ((appKey.bsKey && appKey.bsKey.appPrefix) || appKey.appPrefix);
  let credentials;

  // First try to get credentials from html5 repo
  if (!isHTML5RepoCredsExcluded(req) && !credentials && serviceName) {
    await html5RepoUtils.cacheHTML5Applications(req, appKey);
    credentials = html5RepoUtils.getCredentials(serviceName, req);
    if (credentials && (credentials.uaa || credentials.ias)) {
      req.destinationCredentials = credentials;
    }
  }

  // If no credentials found, try to get from destination service
  if (!req.disabledDestCred && (serviceName && !credentials) || !serviceName) {
    await cacheBSDestinationsProm(req);
    credentials = serviceName && bsUtils.getCredentials(serviceName, true, req);
    if (credentials && (credentials.uaa || credentials.ias)) {
      req.destinationCredentials = credentials;
    }
  }
}

async function dynamicLogLevel(req, res) {
  const path = urijs.parse(req.url).path;
  if (path === '/dynamicLogLevel/info' || path === '/dynamicLogLevel/debug' || path === '/dynamicLogLevel') {
    logRequestInfo(req, `Setting dynamic log level for url ${path}`);
    if (req.method === 'POST') {
      let logLevel;
      if (path.endsWith('info')) {
        logLevel = 'INFO';
      } else if (path.endsWith('debug')) {
        logLevel = 'DEBUG';
      }
      await applicationLogUtils.setDynamicLogLevel(req, logLevel);
      res.end();
    } else if (req.method === 'DELETE') {
      await applicationLogUtils.unsetDynamicLogLevel(req);
      res.end();
    } else {
      const error = new Error('Method not allowed , use POST to set log level or DELETE to unset log level');
      error.status = 405;
      throw (error);
    }
  } else {
    const error = new Error('Invalid url path ' + path);
    error.status = 400;
    throw (error);
  }
}

function getTenant(req) {
  if (!process.env.TENANT_HOST_PATTERN && !req.headers['x-approuter-authorization']) {
    throw new Error('Tenant host pattern or x-approuter-authorization is not defined');
  }
  let urlTenant;
  if (process.env.TENANT_HOST_PATTERN) {
    urlTenant = passportUtils.getUrlTenant(req);
    if (!urlTenant) {
      throw new Error('Failed to determine url tenant');
    }
  }
  if (req.headers['x-approuter-authorization']) {
    if (req.headers['x-subscriber-tenant']) {
      req.tenant = req.headers['x-subscriber-tenant'];
    } else if (req.headers['x-approuter-authorization'].startsWith('Bearer')) {
      const tokenDecoded = jwtDecode(req.headers['x-approuter-authorization']);
      req.tenant = tokenDecoded && tokenDecoded.ext_attr && tokenDecoded.ext_attr.zdn || urlTenant;
    } else if (req.headers['x-approuter-authorization'].startsWith('Basic')) {
      req.tenant = urlTenant;
    }
    req.HTML5AppHost = req.headers['x-runtime-host'] ? req.headers['x-runtime-host'] : urlUtils.getAppRouterHost(req).replace(urlTenant, req.tenant);
  } else {
    req.tenant = urlTenant;
  }
}

function isExcluded(req) {
  const saasApprouterExcludedPath = req.app.get('mainRouterConfig').saasApprouterExcludedPath;
  if (!saasApprouterExcludedPath) {
    return false;
  }
  const firstUrlSegment = urlUtils.getFirstUrlSegment(req, true);
  if (!firstUrlSegment) {
    return false;
  }
  for (let i = 0; i <= saasApprouterExcludedPath.length; i++) {
    if (firstUrlSegment.url.startsWith(saasApprouterExcludedPath[i])) {
      return true;
    }
  }
  return false;
}

function getDisableDestCredentialsAccess(req) {
  let disabledDestCredTenants;
  if (process.env.DISABLED_DEST_CREDS_TENANTS) {
    disabledDestCredTenants = JSON.parse(process.env.DISABLED_DEST_CREDS_TENANTS);
  }
  req.disabledDestCred = disabledDestCredTenants && disabledDestCredTenants.includes(req.tenant);
}

async function getApiName(req, res) {
  const path = urijs.parse(req.url).path;
  let apiName = undefined;
  if (req.headers['x-approuter-authorization']) {
    switch (true) {
    case path.startsWith(DOWNLOAD_APPLICATIONS_API):
      apiName = DOWNLOAD_APPLICATIONS_API;
      break;
    case path.startsWith(GET_APPLICATION_LOGS_API):
      apiName = GET_APPLICATION_LOGS_API;
      break;
    case path.startsWith(GET_APPLICATIONS_API):
      apiName = GET_APPLICATIONS_API;
      break;
    case path.startsWith(DYNAMIC_LOG_LEVEL):
      apiName = DYNAMIC_LOG_LEVEL;
      req.requiredRoleCollection = process.env.LOG_SESSION_ROLE_COLLECTION;
      break;
    }
  }
  apiName && await svc2ApprouterProm(req, res);
  req.apiName = apiName;
  return apiName;
}

function isHTML5RepoCredsExcluded(req) {
  let disabledHTML5RepoCredTenants = false;
  if (process.env.DISABLE_HTML5_REPO_CREDENTIALS) {
    if (process.env.DISABLE_HTML5_REPO_CREDENTIALS === '*') {
      disabledHTML5RepoCredTenants = true;
    } else {
      const subdomains = process.env.DISABLE_HTML5_REPO_CREDENTIALS && process.env.DISABLE_HTML5_REPO_CREDENTIALS.split(',');
      disabledHTML5RepoCredTenants = subdomains && subdomains.indexOf(req.tenant) > -1;
    }
  }
  if (!disabledHTML5RepoCredTenants && req.headers['x-disable-html5-repo-creds']) {
    disabledHTML5RepoCredTenants = true;
  }
  req.isHTML5RepoCredsExcluded = true;
  return disabledHTML5RepoCredTenants;
}
