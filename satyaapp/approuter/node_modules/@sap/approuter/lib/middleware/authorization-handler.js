'use strict';
const loggerUtil = require('../utils/logger');
const {getTenantInfo} = require('../passport/utils');
const logger     = loggerUtil.getLogger('/authorization-handler');
const serviceTokenHandler = require('./service-token-handler');

module.exports = async function checkAuthorization(req) {
  if (!req.internalUrl || req.internalUrl.route.authenticationType === 'none') {
    return {isAuthorized: true};
  }

  const scopesMessage = 'You do not have the required scopes to access this resource.';
  const tenantMessage = 'You cannot use session from another tenant.';
  const loggingData = loggerUtil.getAuditLogAdditionalData(req);
  let auditLogMessage;


  const tenantInfo = getTenantInfo(req);
  if (tenantInfo && tenantInfo.multitenant && tenantInfo.tenant && loggingData.tenant && (tenantInfo.tenant !== loggingData.tenant)) {
    auditLogMessage = 'User not authorized, IP: ' +
        loggingData.IP + ',  JWT token tenant: ' + req.session.user.tenant + ', URL tenant: ' + tenantInfo.tenant;
    loggerUtil.writeToAuditLog(req, loggingData, auditLogMessage, function (err)  {
      if (err) {
        logger.error(err,'Failed to write to audit log');
      }
    });
    return {isAuthorized: false, message: tenantMessage};
  }

  let routeScopes = req.internalUrl.route.scope;
  if (!routeScopes) {
    return {isAuthorized: true};
  }
  if (!Array.isArray(routeScopes)) {
    routeScopes = routeScopes[req.method] || routeScopes.default || [];
  }
  // managed approuter
  const bsScopes = req.session && req.session.user && req.destinationCredentials && req.destinationCredentials.uniqueServiceName
      && req.session.user.businessServices && req.session.user.businessServices[req.destinationCredentials.uniqueServiceName] &&
      req.session.user.businessServices[req.destinationCredentials.uniqueServiceName].scopes;

  // Bound services
  let boundServiceScopes = null;
  try {
    boundServiceScopes = await serviceTokenHandler.getBoundServiceScopes(req);
  } catch (err) {
    logger.error(err, 'Failed to get bound service scopes');
  }
  // standalone approuter
  let sessionScopes = req.session && req.session.user && req.session.user.scopes;
  const oauthScopes = boundServiceScopes || bsScopes || sessionScopes;

  if (!oauthScopes) {
    auditLogMessage = 'User not authorized, the token does not contain scopes, source of route: ' + req.internalUrl.route.source + ', IP: ' +
        loggingData.IP + ',  required scopes: ' + routeScopes + ', user scopes (are missing): ' + oauthScopes;
    loggerUtil.writeToAuditLog(req, loggingData, auditLogMessage, function (err)  {
      if (err) {
        logger.error(err,'Failed to write to audit log');
      }
    });
    return {isAuthorized: false, message: scopesMessage};
  }

  const isAuthorized = routeScopes.some(function (element) {
    return oauthScopes.indexOf(element) > -1;
  });
  const result = {isAuthorized: isAuthorized};

  if (!isAuthorized) {
    auditLogMessage = 'User not authorized, source of route: ' + req.internalUrl.route.source + ', IP: ' +
        loggingData.IP + ',  required scopes: ' + routeScopes + ', user scopes: ' + oauthScopes;
    loggerUtil.writeToAuditLog(req, loggingData, auditLogMessage, function (err)  {
      if (err) {
        logger.error(err,'Failed to write to audit log');
      }
    });
    result.message = scopesMessage;
  }

  return result;
};

function isScopeCheckRequired(appConfig) {
  return appConfig.authenticationMethod !== 'none' &&
         appConfig.routes.some(function(route) {
           return route.scope &&
                  ((Array.isArray(route.scope) && route.scope.length > 0) ||
                   (typeof route.scope === 'object' && Object.keys(route.scope).length > 0));
         });
}

module.exports.isScopeCheckRequired = isScopeCheckRequired;

