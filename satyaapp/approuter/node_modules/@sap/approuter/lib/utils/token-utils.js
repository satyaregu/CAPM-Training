/* eslint-disable camelcase */
'use strict';

const xsenv = require('@sap/xsenv');
const validators = require('../configuration/validators');
const passportUtils = require('../passport/utils');
const loggerUtils = require('./logger');
const headerUtils = require('./header-util');
const tracer = loggerUtils.getTracer(__filename);
const request = require('./request-utils');
const { XsuaaService, IdentityService } = require('@sap/xssec');
const jwtDecode = require('jwt-decode');
const {URL} = require('url');
const {getValidatedEnvInt} = require('./env-utils');
const tokenCache = {};
const timeout = 5000;
let requestsRetryConfig = null;
const minimumTokenValidity = getValidatedEnvInt('MINIMUM_TOKEN_VALIDITY', 0);
const FIVE_MINUTES = 5 * 60 * 1000;

exports.getTokens = getBSTokens;
exports.loadClientCredentialsToken = loadClientCredentialsToken;
exports.getClientCredentialsTokenByTenant = getClientCredentialsTokenByTenant;
exports.getClientCredentialsToken = getClientCredentialsToken;
exports.exchangeToken = exchangeToken;
exports.getRefreshToken = getRefreshToken;
exports.getTokenInfo = getTokenInfo;
exports.getPasswordUserToken = getPasswordUserToken;
exports.deleteTokenCache = deleteTokenCache;
exports.getApp2AppToken = getApp2AppToken;
exports.checkSecurityContext = checkSecurityContext;
exports.createAuthService = createAuthService;
exports.getIASClientCredentialsToken = getIASClientCredentialsToken;
exports.isTokenExpired = isTokenExpired;
exports.isInvalidSubaccount = isInvalidSubaccount;

function createAuthService(credentials, type) {
  const creds = Object.assign({}, credentials.url ? credentials : credentials.uaa || credentials);
  if (creds.url && creds.tokenURL) {
    const parsedCredsUrl = new URL(creds.url);
    const parsedTokenUrl = new URL(creds.tokenURL);
    parsedCredsUrl.host = parsedTokenUrl.host;
    creds.url = parsedCredsUrl.toString();
  }
  creds.apptid && (creds.app_tid = creds.apptid);
  const isIdentityService = type ? type.toLowerCase() === 'ias' : creds.authenticationType === 'ias' || creds.domain || creds.app_tid;
  return isIdentityService ? new IdentityService(creds,{requests: { retry: getXSSECRetryConfig() }}) : new XsuaaService(creds,{requests: { retry: getXSSECRetryConfig() }});
}

function getXSSECRetryConfig() {
  if (requestsRetryConfig !== null) {
    return requestsRetryConfig;
  }
  requestsRetryConfig = {
    'strategy': 'exponential', // The retry strategy (currently only 'exponential' is supported)
    'retries': 3,             // Maximum number of retry attempts
    'initialDelay': 1000,  // Initial delay in milliseconds before the first retry
    'factor': 2,                // Multiplier for the delay after each retry
    'maxDelay': 10000         // Maximum delay in milliseconds between retries
  };
  return requestsRetryConfig;
}

function getBSTokens(app) {
  if (process.env.SKIP_CLIENT_CREDENTIALS_TOKENS_LOAD) {
    if (!app.services) {
      app.services = {};
    }
    return;
  }
  const DESTINATION = 'destination';
  const CONNECTIVITY = 'connectivity';
  const CLIENT_CREDENTIALS = 'client_credentials';

  const services = xsenv.readServices();
  if (services) {
    for (const serviceName in services) {
      const service = services[serviceName];
      if (service.credentials && (service.label === DESTINATION || service.label === CONNECTIVITY || service.credentials['grant_type'] === CLIENT_CREDENTIALS)) {
        validators.validateClientCredentials(service.credentials);
        loadClientCredentialsToken(app, headerUtils.getCorrelationId(), service.credentials, service.credentials['sap.cloud.service'] || service.label);
      }
    }
  }
}

function getTokenInfo(token) {
  const mask = '********';
  try {
    const tokenDecoded = jwtDecode(token);
    // Mask personal information
    tokenDecoded.given_name && (tokenDecoded.given_name = mask);
    tokenDecoded.family_name && (tokenDecoded.family_name = mask);
    tokenDecoded.email && (tokenDecoded.email = mask);
    tokenDecoded.user_uuid && (tokenDecoded.user_uuid = mask);
    tokenDecoded.sub && (tokenDecoded.sub = mask);
    tokenDecoded.name && (tokenDecoded.name = mask);
    tokenDecoded.user_name && (tokenDecoded.user_name = mask);
    return tokenDecoded;
  } catch (err) {
    return {
      invalidToken: err
    };
  }
}

async function getClientCredentialsTokenByTenant(correlationId, tenant, credentials, zoneInfo, cb) {
  const authService = createAuthService(credentials);
  const zid = zoneInfo && zoneInfo.apptid;
  try {
    const tokenResponse = await authService.fetchClientCredentialsToken({ correlationId, tenant, zid, timeout });
    const tokenResponseOptions = handleClientCredentialsTokenResponse(
      createTokenResponseOptions(null, tokenResponse, credentials.label, tenant, correlationId)
    );
    if (tokenResponseOptions.errorMessage) {
      const error = new Error(tokenResponseOptions.errorMessage);
      if (cb) {
        return cb(error);
      } else {
        throw error;
      }
    } else {
      if (cb) {
        return cb(null, tokenResponseOptions);
      } else {
        return tokenResponseOptions;
      }
    }
  } catch (err) {
    const tokenResponseOptions = handleClientCredentialsTokenResponse(
      createTokenResponseOptions(err, null, credentials.label, tenant, correlationId)
    );
    tracer.error(`Error getting client_credentials token for ${credentials.label} from subaccount ${tenant}: ${err.message}`);
    const exceptionErr = new Error(tokenResponseOptions.errorMessage || err.message);
    if (cb) {
      return cb(exceptionErr);
    } else {
      throw exceptionErr;
    }
  }
}

async function loadClientCredentialsToken(app, correlationId, credentials, serviceName, cb) {
  const authService = createAuthService(credentials);
  try {
    tracer.info(`Loading client credentials token for service: ${serviceName}`);
    const tokenResponse = await authService.fetchClientCredentialsToken({ correlationId, timeout });
    const tokenResponseOptions = handleClientCredentialsTokenResponse(
      createTokenResponseOptions(null, tokenResponse, serviceName, credentials.identityzone, correlationId)
    );
    if (tokenResponseOptions.errorMessage) {
      tracer.error(tokenResponseOptions.errorMessage);
      return cb && cb(tokenResponseOptions.errorMessage);
    }
    if (!app.services) {
      app.services = {};
    }
    if (!app.services[serviceName]) {
      app.services[serviceName] = {};
    }
    app.services[serviceName].token = tokenResponseOptions;
    const tokenRefreshTimestamp = passportUtils.getExpiresAt(tokenResponse.expires_in).getTime() - FIVE_MINUTES;
    const msBeforeRetrieval = Math.max(0, tokenRefreshTimestamp - Date.now()); // Prevent negative timeout
    setTimeout(() => loadClientCredentialsToken(app, correlationId, credentials, serviceName), msBeforeRetrieval);
    return cb && cb();
  } catch (err) {
    const tokenResponseOptions = handleClientCredentialsTokenResponse(
      createTokenResponseOptions(err, null, serviceName, credentials.identityzone, correlationId)
    );

    tracer.error(tokenResponseOptions.errorMessage || err.message);
    return cb && cb(err || tokenResponseOptions.errorMessage);
  }
}

async function getApp2AppToken(idToken, credentials, IASDependencyName, correlationId) {
  const authService = createAuthService(credentials);
  try {
    return await authService.fetchJwtBearerToken(idToken, { correlationId, timeout , resource: `urn:sap:identity:application:provider:name:${IASDependencyName}` });
  } catch (err) {
    const tokenInfo = idToken && (JSON.stringify(getTokenInfo(idToken)));
    throw new Error(`Failed to exchange IAS token: ${err.responseText || err.message}, IASDependencyName=${IASDependencyName}, token details - ${tokenInfo}`);
  }
}

async function getIASClientCredentialsToken(credentials, serviceInstanceId, correlationId) {
  const authService = createAuthService(credentials, 'ias');
  try {
    const tokenResponse = await authService.fetchClientCredentialsToken({ correlationId, timeout , resource: `urn:sap:identity:application:service:id:${serviceInstanceId}` });
    return handleClientCredentialsTokenResponse(
      createTokenResponseOptions(null, tokenResponse, credentials.label, credentials.tenant, correlationId)
    );
  } catch (err) {
    throw new Error(`Failed to create client credentials IAS token for service ${credentials.label}: ${err.responseText || err.message}, Service instance id=${serviceInstanceId}`);
  }
}

async function exchangeToken(loginToken, correlationId, externalServiceCredentials, cb) {
  try {
    const tokenDecoded = loginToken && loginToken.length > 100 ? jwtDecode(loginToken) : null;
    const tenant = tokenDecoded && tokenDecoded.ext_attr && tokenDecoded.ext_attr.zdn;
    const apptid = tokenDecoded && (tokenDecoded.app_tid || tokenDecoded.zone_uuid);
    const authService = createAuthService(externalServiceCredentials);
    const tokenResponse = await authService.fetchJwtBearerToken(loginToken, { correlationId, tenant, zid: apptid , timeout });
    if (cb) {
      return cb(null, tokenResponse.access_token, tokenResponse);
    }
    return {accessToken: tokenResponse.access_token, tokenResponse: tokenResponse};
  } catch (err) {
    const identityZone = externalServiceCredentials && externalServiceCredentials.identityzone;
    const clientId = externalServiceCredentials && externalServiceCredentials.clientid;
    const error = new Error(`Failed to exchange token: ${err.responseText || err.message}, token details - ${JSON.stringify(getTokenInfo(loginToken))}, external service credentials details - identityzone: ${identityZone} clientid: ${clientId}`);
    if (cb) {
      return cb(error);
    } else {
      throw error;
    }
  }
}

async function getClientCredentialsToken(tenant, correlationId, credentials, apptid) {
  const authService = createAuthService(credentials);
  try {
    const tokenResponse = await authService.fetchClientCredentialsToken({ correlationId, tenant, zid: apptid , timeout });
    return handleClientCredentialsTokenResponse(
      createTokenResponseOptions(null, tokenResponse, credentials.label, tenant, correlationId)
    );
  } catch (err) {
    return  handleClientCredentialsTokenResponse(
      createTokenResponseOptions(err, null, credentials.label, tenant, correlationId)
    );
  }
}

function deleteTokenCache(tokenKey) {
  if (tokenCache[tokenKey]) {
    delete tokenCache[tokenKey];
  }
}

async function getPasswordUserToken(tenant, userCreds, credentials, correlationId) {
  const tokenKey = tenant + userCreds.name + userCreds.pass;
  if (tokenCache[tokenKey] && tokenCache[tokenKey].tokenRefreshTimestamp > Date.now()) {
    return tokenCache[tokenKey];
  }
  const authService = createAuthService(credentials);
  try {
    const tokenResponse = await authService.fetchPasswordToken(userCreds.name, userCreds.pass, { correlationId, tenant , timeout });
    const tokenResponseOptions = handleUserTokenResponse(
      createTokenResponseOptions(null, tokenResponse, credentials.label, tenant, correlationId), tokenResponse
    );
    tokenCache[tokenKey] = tokenResponseOptions;
    return tokenResponseOptions;
  } catch (err) {
    throw new Error(`Error getting user token for ${credentials.label} from subaccount ${tenant} error: ${err.message}`);
  }
}

function getRefreshToken(accessToken, uaaOptions) {
  const requestOptions = {
    url: uaaOptions.tokenURL,
    headers: {
      'content-type': 'application/x-www-form-urlencoded;charset=utf-8',
      'accept': 'application/json;charset=utf-8',
      'Authorization': `Bearer ${accessToken}`
    },
    form: {
      'client_id': uaaOptions.clientid,
      'grant_type': 'user_token',
      'token_format': 'jwt'
    }
  };
  return new Promise((resolve, reject) => {
    request.post(requestOptions, (err, res, body) => {
      if (err || res.statusCode !== 200) {
        return reject(`Failed to create refresh token ${err ? err : res.response && res.response.data}`);
      }
      if (!body) {
        return reject('Refresh token missing in response from XSUAA');
      }
      try {
        const tokenData = JSON.parse(body);
        tokenData.refresh_token ? resolve(tokenData) : reject(`Failed to parse token ${body}`);
      } catch (err) {
        reject(`Failed to parse refresh token ${err}`);
      }
    });
  });
}

function createTokenResponseOptions(err, token, serviceName, subaccount, correlationId) {
  return {
    err: err,
    accessToken: token && token.access_token,
    expiration: token && token.expires_in,
    tokenType: token && token.token_type,
    serviceName: serviceName,
    subaccount: subaccount,
    correlationId: correlationId
  };
}

function handleClientCredentialsTokenResponse(tokenResponseOptions) {
  if (tokenResponseOptions.err) {
    return {
      errorMessage: `Error getting client_credentials token for ${tokenResponseOptions.serviceName} from subaccount ${tokenResponseOptions.subaccount} error: ${tokenResponseOptions.err.message}`
    };
  }
  if (!tokenResponseOptions.accessToken || !tokenResponseOptions.expiration) {
    return {
      errorMessage: new Error(`Bad response from UAA when getting client credentials token for ${tokenResponseOptions.serviceName} - not all fields are present`)
    };
  }

  if (minimumTokenValidity > 0 && tokenResponseOptions.expiration < minimumTokenValidity) {
    return {
      errorMessage: new Error(`Token validity for service ${tokenResponseOptions.serviceName} in subaccount ${tokenResponseOptions.subaccount} is lower than the minimum token validity of ${process.env.MINIMUM_TOKEN_VALIDITY} seconds, please increase token validity above this value. To set the token validity on subaccount level refer to: https://api.sap.com/api/SecuritySettingsAPI/resource`)
    };
  }
  tracer.info(`Token validity for service ${tokenResponseOptions.serviceName} in subaccount ${tokenResponseOptions.subaccount} with correlationId ${tokenResponseOptions.correlationId} is ${tokenResponseOptions.expiration}`);
  return createTokenOptions(
    tokenResponseOptions.accessToken,
    tokenResponseOptions.tokenType,
    passportUtils.getExpiresAt(tokenResponseOptions.expiration).getTime()
  );
}

function handleUserTokenResponse(tokenResponseOptions, tokenDecoded) {
  if (tokenResponseOptions.err) {
    return {
      errorMessage: `Error getting user token for ${tokenResponseOptions.serviceName} from subaccount ${tokenResponseOptions.subaccount} error: ${tokenResponseOptions.err.message}`
    };
  }
  if (!tokenResponseOptions.accessToken || !tokenResponseOptions.expiration) {
    return {
      errorMessage: new Error(`Bad response from UAA when user token for ${tokenResponseOptions.serviceName} - not all fields are present`)
    };
  }
  tracer.info(`Token validity for service ${tokenResponseOptions.serviceName} in subaccount ${tokenResponseOptions.subaccount} with correlationId ${tokenResponseOptions.correlationId} is ${tokenResponseOptions.expiration}`);
  const tokenInfo = getTokenInfo(tokenDecoded.access_token);
  Object.assign(tokenDecoded, {
    exp: tokenInfo.expiration,
    roleCollections: tokenInfo.roleCollections
  });
  return createTokenOptions(
    tokenResponseOptions.accessToken,
    tokenResponseOptions.tokenType,
    passportUtils.getExpiresAt(tokenResponseOptions.expiration).getTime(),
    tokenDecoded
  );
}

async function checkSecurityContext(token, conf) {
  const { credentials, type, correlationId } = conf;
  const authService = createAuthService(credentials,type);
  try {
    return await authService.createSecurityContext(token,{correlationId});
  } catch (error) {
    throw new Error(`Failed to create security context: ${error.message}`);
  }
}

function createTokenOptions(accessToken, tokenType, timeStamp, tokenDecoded) {
  return { accessToken, tokenType, tokenRefreshTimestamp: timeStamp, tokenDecoded };
}

function isTokenExpired(token) {
  return token.tokenRefreshTimestamp - Date.now() <= FIVE_MINUTES;
}

function isInvalidSubaccount(errorMessage) {
  if (!errorMessage || typeof errorMessage !== 'string') {
    return false;
  }

  // Extract HTTP status code that follows a space
  return errorMessage.indexOf(' 404') !== -1;
}
